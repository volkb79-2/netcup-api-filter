# =============================================================================
# NETCUP API FILTER - ENVIRONMENT DEFAULTS
# =============================================================================
# Purpose: Default values for all deployments (local, staging, production)
# Status: Version-controlled, safe to commit (contains only defaults)
#
# CRITICAL: This file is the single source of truth for default values
# DO NOT hardcode these values in Python code, scripts, or templates
#
# Hierarchy: os.environ → .env → hardcoded fallback
# =============================================================================

# ===============  Current Configuration Structure  ===========================
#
# .env.defaults (COMMITTED, skeleton, **no** secrets)
# └── Default values for all deployments
#     ├── Admin credentials (seeding only)
#     ├── Flask configuration
#     ├── Worker settings
#     └── Testing configuration (marked clearly)

# .env          (GITIGNORED, **copy** from .env.defaults **with secrets**)

# .env.services (COMMITTED)
# └── Docker service naming registry
#     └── Container names, URLs, network config

# .env.workspace (AUTO-GENERATED, GITIGNORED)
# └── Runtime workspace configuration
#     ├── Detected FQDN
#     ├── Public IP
#     ├── Certificate paths
#     └── Docker network

# .env (USER OVERRIDES, GITIGNORED, OPTIONAL)
# └── Local developer overrides
#     └── Production secrets

# deployment_state_*.json (GITIGNORED)
# └── Track live deployment credentials
#     ├── Current admin password
#     ├── Client credentials
#     └── Deployment metadata
#
# =========================  Configuration Sections  ==========================

# =============================================================================
# DEPLOYMENT CONFIGURATION
# =============================================================================
# Environment-specific URLs, ports, and SSH credentials
#
# Applicability: Used by deployment scripts, not by application runtime
# Override: Via environment variables in CI/CD or local .env
# =============================================================================

# Webhosting production URL (used for remote tests and screenshots)
WEBHOSTING_URL=https://naf.vxxu.de

# Local Flask port
LOCAL_FLASK_PORT=5100

# Whether to use HTTPS by default for local testing
# When true, deploy.sh will start TLS proxy and use HTTPS URLs
# HTTPS is default to match production environment
LOCAL_USE_HTTPS=true

# Local base URL is computed by deploy.sh and exported as UI_BASE_URL

# TLS proxy settings (from tooling/reverse-proxy/proxy.env)
# These are read from proxy.env at runtime
# PUBLIC_FQDN is auto-detected via reverse DNS (see .env.workspace)
# LOCAL_TLS_BIND_HTTPS=443

# =============================================================================
# DEFAULT ADMIN CREDENTIALS
# =============================================================================
# Used ONLY for fresh database seeding during build_deployment.py
#
# Applicability: Build time only (database seeding)
# Security: Operator MUST change password on first login
# Production: Credentials stored in deployment_state_*.json after password change
# =============================================================================

# Default admin credentials (used for fresh database seeding)
DEFAULT_ADMIN_USERNAME=admin
DEFAULT_ADMIN_PASSWORD=admin
# Default admin email (admin@localhost triggers email setup flow on first login)
DEFAULT_ADMIN_EMAIL=admin@localhost

# =============================================================================
# DEFAULT DEMO ACCOUNT (TESTING ONLY)
# =============================================================================
# Used for account portal UI tests and smoke checks (seeded when demo seeding is enabled).
# Username also doubles as the default test client ID in some seeding paths.
DEFAULT_TEST_CLIENT_ID=demo-user
# Password for the demo account (seeded value). Override via environment variable if needed.
DEFAULT_TEST_ACCOUNT_PASSWORD=DemoPassword123!

# =============================================================================
# FLASK SECURITY CONFIGURATION
# =============================================================================
# Session management and cookie security
#
# Applicability: ALL environments (local, staging, production)
# CRITICAL: SECRET_KEY MUST be overridden in production (see below)
# =============================================================================

# Flask secret key for session signing
# ⚠️ PRODUCTION REQUIREMENT: Override via environment variable
# Generate secure key: export SECRET_KEY=$(openssl rand -hex 32)
# Default is for development ONLY - application will refuse to start in
# production without a custom SECRET_KEY
SECRET_KEY=local-dev-secret-change-me

# =============================================================================
# ADMIN SECURITY CONFIGURATION
# =============================================================================
# Access control and authentication settings for admin panel
#
# Applicability: Runtime configuration (can be moved to database Settings table)
# Recommendation: Consider moving ADMIN_IP_WHITELIST to Settings table for
#                 dynamic configuration via admin UI
# =============================================================================

# Admin IP whitelist (comma-separated IPs/CIDRs)
# Empty = allow all (development), set in production for security
# Example: ADMIN_IP_WHITELIST=192.168.1.0/24,10.0.0.1
ADMIN_IP_WHITELIST=

# Bind admin sessions to originating IP (prevents session hijacking)
# May cause issues with mobile networks/VPNs - enable only in high-security environments
ADMIN_SESSION_BIND_IP=true

# Rate limiting for admin/account routes (requests per minute)
# Protects against brute-force attacks and excessive API usage
# Format: "<number> per <unit>" (e.g., "10 per minute", "100 per hour")
# These defaults are used when Settings table has no values
ADMIN_RATE_LIMIT="50 per minute"
ACCOUNT_RATE_LIMIT="50 per minute"
API_RATE_LIMIT="60 per minute"

# Skip 2FA for admin login (TESTING ONLY!)
# REQUIRES FLASK_ENV=local_test - has no effect in production
# Set to true to bypass 2FA during automated UI tests
ADMIN_2FA_SKIP=false

# Minimum interval between admin 2FA emails (seconds)
# Prevents runaway automation loops from spamming SMTP/IMAP.
ADMIN_2FA_EMAIL_MIN_INTERVAL_SECONDS=30

# 2FA Security Settings
# Maximum failed 2FA attempts before account lockout
TFA_MAX_ATTEMPTS=5
# Account lockout duration after max failed 2FA attempts (minutes)
TFA_LOCKOUT_MINUTES=30

# Recovery Code Security
# Maximum failed recovery code attempts before lockout
RECOVERY_CODE_MAX_ATTEMPTS=3
# Recovery code lockout duration (minutes)
RECOVERY_CODE_LOCKOUT_MINUTES=30
# Number of recovery codes generated per account
RECOVERY_CODE_COUNT=3

# Flask session configuration (NO HARDCODED VALUES IN CODE!)
# Session cookie security settings
FLASK_SESSION_COOKIE_SECURE=auto
FLASK_SESSION_COOKIE_HTTPONLY=True
FLASK_SESSION_COOKIE_SAMESITE=Lax
# Session timeout in seconds (3600 = 1 hour)
FLASK_SESSION_LIFETIME=3600

# Session cookie domain (for TLS proxy scenarios)
# When using a reverse proxy with a public FQDN, set this to the public domain
# so browser sends cookies through the proxy (not just to internal hostname)
# auto = Use PUBLIC_FQDN if available, otherwise use Flask default (current domain)
# empty = Flask default (cookie domain = current request hostname)
# .example.com = Explicit domain (leading dot allows subdomains)
# Example: FLASK_SESSION_COOKIE_DOMAIN=.${PUBLIC_FQDN}
FLASK_SESSION_COOKIE_DOMAIN=auto

# =============================================================================
# SCREENSHOT CONFIGURATION
# =============================================================================
# Viewport dimensions for UI screenshot capture
#
# Applicability: Testing and documentation generation
# Override: Via environment variables in CI/CD
# =============================================================================

# Screenshot viewport dimensions (NO HARDCODED VALUES IN CODE!)
SCREENSHOT_VIEWPORT_WIDTH=1920
SCREENSHOT_VIEWPORT_HEIGHT=2000

# =============================================================================
# PYTEST PROFILING (TESTING ONLY)
# =============================================================================
# Optional per-test cProfile profiling for time spent *inside* each test.
# Enable for local/debug runs only; output can be verbose.
#
# Applies in the Playwright container (run_in_playwright) when these vars are
# passed through (see tooling/playwright/playwright-exec.sh).

# Enable per-test profiling
PYTEST_PROFILE_ENABLED=false

# Only emit profiles for tests whose call-phase duration >= this threshold (seconds)
PYTEST_PROFILE_MIN_SECONDS=1.0

# Where to write .prof files (workspace path)
PYTEST_PROFILE_DIR=tmp/pytest_profiles

# pstats sort key (e.g., tottime, cumtime)
PYTEST_PROFILE_SORT=tottime

# Number of functions to print per profiled test
PYTEST_PROFILE_TOP=30

# =============================================================================
# GUNICORN WORKER CONFIGURATION
# =============================================================================
# Process/thread settings for production WSGI server
#
# Applicability: Production and local testing (not used by Flask dev server)
# NOTE (deploy.sh): Local deployments start gunicorn using `gunicorn.conf.py`.
# All tunables are read from these `GUNICORN_*` environment variables (defaults live here).
# For reliable local HTTPS testing behind the TLS proxy, keep `GUNICORN_RELOAD=false`.
# Auto-reload can restart workers mid-request and show up as intermittent `502 Bad Gateway`.
# Auto-detection: GUNICORN_WORKERS defaults to 2*CPU+1 if not set
# Override: Via environment variables based on server resources
# =============================================================================

# Worker class: sync, gthread, gevent, eventlet
# - sync: Simple synchronous (1 request/worker at a time)
# - gthread: Threaded (multiple requests/worker via threads)
# - gevent/eventlet: Async I/O (1000s of concurrent connections)
GUNICORN_WORKER_CLASS=gthread

# Number of worker processes (auto = 2*CPU+1, capped at 8)
# Leave empty for auto-detection based on CPU cores
# GUNICORN_WORKERS=4

# Threads per worker (gthread only) - I/O concurrency per process
GUNICORN_THREADS=4

# Max concurrent connections per worker (gevent/eventlet only)
GUNICORN_WORKER_CONNECTIONS=1000

# Request timeout (seconds) - Netcup API can be slow
GUNICORN_TIMEOUT=120

# Graceful shutdown timeout
GUNICORN_GRACEFUL_TIMEOUT=30

# Keep-alive connections (seconds)
GUNICORN_KEEPALIVE=5

# Max requests before worker restart (memory leak prevention)
GUNICORN_MAX_REQUESTS=1000
GUNICORN_MAX_REQUESTS_JITTER=50

# Connection backlog (pending connections queue)
GUNICORN_BACKLOG=2048

# Bind address
GUNICORN_BIND=0.0.0.0:5100

# Log level: debug, info, warning, error, critical
GUNICORN_LOGLEVEL=info

# Auto-reload on code changes (development only)
GUNICORN_RELOAD=false

# =============================================================================
# GEOIP CONFIGURATION
# =============================================================================
# MaxMind GeoLite2 Web Services integration
#
# Applicability: Production feature (IP geolocation for security/analytics)
# Required: MAXMIND_ACCOUNT_ID and MAXMIND_LICENSE_KEY for production
# Local Testing: Override MAXMIND_API_URL to use mock server
# Get Credentials: https://www.maxmind.com/en/geolite2/signup
#
# NOTE: geoIP.conf is OBSOLETE - use environment variables or Settings table
#       The old config file contained credentials and was committed (security risk)
#       All GeoIP config now uses env vars or database Settings table
# =============================================================================

# MaxMind account credentials (get from maxmind.com)
# Leave empty to disable GeoIP lookups
MAXMIND_ACCOUNT_ID=
MAXMIND_LICENSE_KEY=

# API URL override for local testing with mock server
# Production uses https://geoip.maxmind.com (default)
# Local testing: http://mock-geoip:5556
MAXMIND_API_URL=

# GeoIP cache settings
GEOIP_CACHE_HOURS=24
GEOIP_CACHE_SIZE=1000

# =============================================================================
# POWERDNS BACKEND CONFIGURATION
# =============================================================================
# PowerDNS Authoritative Server integration (alternative to Netcup CCP API)
#
# Applicability: Local development (self-hosted DNS)
# Production: Typically uses Netcup CCP API instead
# Purpose: Provides low-TTL DNS for testing and self-hosted scenarios
# =============================================================================

# PowerDNS API credentials (config-driven, never hardcoded)
# Generate secure API key: openssl rand -hex 32
POWERDNS_API_KEY=

# PowerDNS connectivity tuning (config-driven; used by auto-detection helpers)
# Internal (Docker network) endpoint, only when HOSTNAME_POWERDNS is set
POWERDNS_INTERNAL_SCHEME=http
POWERDNS_INTERNAL_API_PORT=8081

# Public reverse-proxy endpoint (recommended for production-parity and webhosting live tests)
POWERDNS_PROXY_SCHEME=https
POWERDNS_PROXY_PATH=/backend-powerdns
POWERDNS_PROXY_API_URL=${POWERDNS_PROXY_SCHEME}://${PUBLIC_FQDN}${POWERDNS_PROXY_PATH}

# PowerDNS API URL (recommended default)
# Default: computed from PUBLIC_FQDN via reverse proxy route (see POWERDNS_PROXY_* above)
# Override for remote PowerDNS instances
# Example: https://${PUBLIC_FQDN}/backend-powerdns
POWERDNS_API_URL=${POWERDNS_PROXY_API_URL}

# PowerDNS DNS server address (public, port 53)
# Used for DNS delegation NS records
# Auto-detected from PUBLIC_FQDN
# Example: ${PUBLIC_FQDN} (A/AAAA records point to PowerDNS container host)
POWERDNS_NS_HOSTNAME=

# Default TTL for PowerDNS records (seconds)
# Benefit of self-hosting: can set as low as 1 second
POWERDNS_DEFAULT_TTL=60

# powerdns SOA (domain delegated to this powerdns instance)
POWERDNS_SOA=powerhosts.vxxu.de


# =============================================================================
# IMAP CONFIGURATION (TESTING ONLY)
# =============================================================================
# Live email verification testing via IMAP
#
# Applicability: Optional - only for test_live_email_verification.py
# Production: Not used (Mailpit for SMTP testing, no IMAP needed)
# Purpose: Verify email delivery to real mailboxes during development
# NOTE: Mailpit configuration is in tooling/mailpit/.env (container-specific)
# =============================================================================

# Used for test_live_email_verification.py to verify email delivery
# Configure these for live mode testing only

# IMAP server hostname
IMAP_HOST=
# IMAP port (993 for TLS, 143 for STARTTLS)
IMAP_PORT=993
# IMAP username (usually email address)
IMAP_USER=
# IMAP password
IMAP_PASSWORD=
# Use TLS for IMAP connection
IMAP_USE_TLS=true
# Mailbox to check (usually INBOX)
IMAP_MAILBOX=INBOX
# Optional: check multiple mailboxes (comma-separated). If set, overrides IMAP_MAILBOX.
# Example: IMAP_MAILBOXES=INBOX,Spam,Junk
IMAP_MAILBOXES=
# Timeout in seconds for IMAP operations
IMAP_TIMEOUT=30

# Optional: how many most-recent messages per mailbox to scan during IMAP polling
# (increase if your mailbox receives high volume).
IMAP_MESSAGE_LOOKBACK=10

# =============================================================================
# LIVE DNS VERIFICATION CONFIGURATION (TESTING ONLY)
# =============================================================================
# DNS propagation testing via live DNS servers
#
# Applicability: Optional - only for test_live_dns_verification.py
# Production: Not used
# Purpose: Verify DNS record changes propagate correctly
# =============================================================================

# Used for test_live_dns_verification.py to verify DNS changes
# Configure with a subdomain you control for testing

# Root domain (zone) that is served by your live DNS backend for testing
# Example: example.com
# Required for record lifecycle tests; leave empty to skip those tests
DNS_TEST_DOMAIN=

# Test subdomain prefix (will create records like <prefix>.example.com)
DNS_TEST_SUBDOMAIN_PREFIX=_naftest
# DNS propagation check timeout in seconds
DNS_PROPAGATION_TIMEOUT=300
# DNS propagation poll interval in seconds (how often to query resolvers)
DNS_PROPAGATION_POLL_INTERVAL=10
# DNS servers to check for propagation
DNS_CHECK_SERVERS=8.8.8.8,1.1.1.1

# =============================================================================
# UI 2FA EMAIL RETRIEVAL (TESTING ONLY)
# =============================================================================
# Used by Playwright workflows when handling /login/2fa pages.

# Optional: persist/reuse Playwright storage state (cookies/localStorage) across test runs.
# When set to an existing file, browser sessions load it; after a successful admin login,
# workflows save updated state back to this path.
UI_PLAYWRIGHT_STORAGE_STATE_PATH=

# Clear persisted Playwright auth state file after the pytest run.
# Useful when you explicitly want the next run to re-test the 2FA/login flow.
UI_CLEAR_AUTH_STATE_ON_EXIT=0
# Tries Mailpit first; may fall back to IMAP if configured.

# =============================================================================
# EMAIL REFERENCE IDS (RUNTIME)
# =============================================================================
# Email reference IDs appear in email footers and logs (e.g. Ref: NAF-2FA-...).
# The random token portion can be grouped for readability: GROUP_SIZE=6 and
# GROUPS=2 yields tokens like FIHY56-AVJE34.

NAF_EMAIL_REF_RANDOM_GROUP_SIZE=6
NAF_EMAIL_REF_RANDOM_GROUPS=2

# 2FA email subject template.
# Available placeholders: {ref_token} (recommended), {ref} (full ref), {username}
NAF_2FA_EMAIL_SUBJECT_TEMPLATE='[Netcup API Filter] Your Login Verification Code (Ref {ref_token})'

# Max time to wait for 2FA email to arrive (seconds)
UI_2FA_EMAIL_TIMEOUT=30
# Poll interval while waiting for 2FA email (seconds)
UI_2FA_EMAIL_POLL_INTERVAL=0.5

# Admin login robustness for live/proxied runs
UI_ADMIN_LOGIN_ATTEMPTS=2
UI_ADMIN_LOGIN_RETRY_DELAY=1.0

# Journey 1: after a forced admin password change, optionally verify the new
# password by logging out and logging back in.
# On webhosting/live deployments this may trigger an extra email-based 2FA send
# and can hit SMTP rate limits, so the test code defaults to skipping unless
# explicitly enabled.
UI_J1_VERIFY_PASSWORD_AFTER_CHANGE=1

# IMAP strategy: reduce chance of stale-code false positives by clicking “resend”
# and only accepting emails that arrive AFTER a baseline snapshot.
# This is only used when UI_2FA_CHANNELS includes "imap" and IMAP_* is configured.
UI_2FA_IMAP_FORCE_RESEND=false

# Journey 3 token creation on webhosting/live deployments.
# J3 creates synthetic accounts with non-deliverable emails by default, so token
# creation is disabled unless explicitly enabled.
UI_J3_CREATE_TOKENS_WEBHOSTING=0

# =============================================================================
# DDNS PROTOCOL SUPPORT
# =============================================================================
# DynDNS2 and No-IP compatible DDNS endpoints
#
# Applicability: Runtime feature flag (can be moved to database Settings table)
# Production: Typically enabled for dynamic IP clients (home routers, etc.)
# Recommendation: Consider moving to Settings table for dynamic configuration
# =============================================================================

# Configuration for DynDNS2 and No-IP compatible DDNS endpoints

# Enable DDNS protocol endpoints (/api/ddns/dyndns2/update, /api/ddns/noip/update)
DDNS_PROTOCOLS_ENABLED=true

# Keywords that trigger auto IP detection (comma-separated, case-insensitive)
# When myip parameter matches any of these (or is empty), use client IP
# Example: myip=auto, myip=public, myip=detect, myip= (empty)
DDNS_AUTO_IP_KEYWORDS=auto,public,detect


# =============================================================================
# WEBHOSTING DEPLOYMENT CONFIGURATION
# =============================================================================
# SSH credentials and paths for webhosting deployment target
#
# Applicability: Deployment scripts only (deploy.sh)
# Production: Used by CI/CD or manual deployments via ./deploy.sh webhosting
# Override: Via environment variables or .env (for secrets)
# =============================================================================

# for webhosting deployment
WEBHOSTING_SSH_USER=
WEBHOSTING_SSH_HOST=
WEBHOSTING_REMOTE_DIR=/netcup-api-filter

