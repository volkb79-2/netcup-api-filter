# Default values for netcup-api-filter deployment
# This file is the single source of truth for default credentials
# DO NOT hardcode these values anywhere else

# =============================================================================
# DEPLOYMENT CONFIGURATION (Environment-Specific)
# =============================================================================

# Webhosting production URL (used for remote tests and screenshots)
WEBHOSTING_URL=https://naf.vxxu.de

# Local Flask port
LOCAL_FLASK_PORT=5100

# Whether to use HTTPS by default for local testing
# When true, deploy.sh will start TLS proxy and use HTTPS URLs
# HTTPS is default to match production environment
LOCAL_USE_HTTPS=true

# Local base URL (dynamically constructed from PUBLIC_FQDN and LOCAL_USE_HTTPS)
# This is computed at runtime, not hardcoded
# Scripts should call: get_local_base_url (defined below)
# HTTP: http://localhost:5100 (direct Flask access, LOCAL_USE_HTTPS=false)
# HTTPS: https://$PUBLIC_FQDN (via TLS proxy with Let's Encrypt certs, LOCAL_USE_HTTPS=true)
LOCAL_BASE_URL=

# Helper function to compute LOCAL_BASE_URL dynamically
# Usage in bash scripts:
#   source .env.workspace  # Get PUBLIC_FQDN
#   source .env.defaults   # Get this function
#   LOCAL_BASE_URL=$(get_local_base_url)
get_local_base_url() {
    local use_https="${LOCAL_USE_HTTPS:-true}"
    local flask_port="${LOCAL_FLASK_PORT:-5100}"
    
    # Source PUBLIC_FQDN if not already set
    if [[ -z "${PUBLIC_FQDN:-}" ]]; then
        if [[ -f "${REPO_ROOT:-.}/.env.workspace" ]]; then
            source "${REPO_ROOT:-.}/.env.workspace"
        fi
    fi
    
    if [[ "$use_https" == "true" ]]; then
        echo "https://${PUBLIC_FQDN:-localhost}"
    else
        echo "http://localhost:${flask_port}"
    fi
}

# TLS proxy settings (from tooling/reverse-proxy/proxy.env)
# These are read from proxy.env at runtime
# PUBLIC_FQDN is auto-detected via reverse DNS (see .env.workspace)
# LOCAL_TLS_BIND_HTTPS=443

# Default admin credentials (used for fresh database seeding)
DEFAULT_ADMIN_USERNAME=admin
DEFAULT_ADMIN_PASSWORD=admin
# Default admin email (admin@localhost triggers email setup flow on first login)
DEFAULT_ADMIN_EMAIL=admin@localhost

# Flask secret key for session signing (override per environment!)
SECRET_KEY=local-dev-secret-change-me

# =============================================================================
# ADMIN SECURITY CONFIGURATION
# =============================================================================

# Admin IP whitelist (comma-separated IPs/CIDRs)
# Empty = allow all (development), set in production for security
# Example: ADMIN_IP_WHITELIST=192.168.1.0/24,10.0.0.1
ADMIN_IP_WHITELIST=

# Bind admin sessions to originating IP (prevents session hijacking)
# May cause issues with mobile networks/VPNs - enable only in high-security environments
ADMIN_SESSION_BIND_IP=true

# Skip 2FA for admin login (TESTING ONLY!)
# REQUIRES FLASK_ENV=local_test - has no effect in production
# Set to true to bypass 2FA during automated UI tests
ADMIN_2FA_SKIP=false

# Flask session configuration (NO HARDCODED VALUES IN CODE!)
# Session cookie security settings
FLASK_SESSION_COOKIE_SECURE=auto
FLASK_SESSION_COOKIE_HTTPONLY=True
FLASK_SESSION_COOKIE_SAMESITE=Lax
# Session timeout in seconds (3600 = 1 hour)
FLASK_SESSION_LIFETIME=3600

# Screenshot viewport dimensions (NO HARDCODED VALUES IN CODE!)
SCREENSHOT_VIEWPORT_WIDTH=1920
SCREENSHOT_VIEWPORT_HEIGHT=2000

# =============================================================================
# GUNICORN WORKER CONFIGURATION (Dynamic Resource Regulation)
# =============================================================================

# Worker class: sync, gthread, gevent, eventlet
# - sync: Simple synchronous (1 request/worker at a time)
# - gthread: Threaded (multiple requests/worker via threads)
# - gevent/eventlet: Async I/O (1000s of concurrent connections)
GUNICORN_WORKER_CLASS=gthread

# Number of worker processes (auto = 2*CPU+1, capped at 8)
# Leave empty for auto-detection based on CPU cores
# GUNICORN_WORKERS=4

# Threads per worker (gthread only) - I/O concurrency per process
GUNICORN_THREADS=4

# Max concurrent connections per worker (gevent/eventlet only)
GUNICORN_WORKER_CONNECTIONS=1000

# Request timeout (seconds) - Netcup API can be slow
GUNICORN_TIMEOUT=120

# Graceful shutdown timeout
GUNICORN_GRACEFUL_TIMEOUT=30

# Keep-alive connections (seconds)
GUNICORN_KEEPALIVE=5

# Max requests before worker restart (memory leak prevention)
GUNICORN_MAX_REQUESTS=1000
GUNICORN_MAX_REQUESTS_JITTER=50

# Connection backlog (pending connections queue)
GUNICORN_BACKLOG=2048

# Bind address
GUNICORN_BIND=0.0.0.0:5100

# Log level: debug, info, warning, error, critical
GUNICORN_LOGLEVEL=info

# Auto-reload on code changes (development only)
GUNICORN_RELOAD=false

# =============================================================================
# GEOIP CONFIGURATION (MaxMind Web Services)
# =============================================================================

# MaxMind account credentials (get from maxmind.com)
# Leave empty to disable GeoIP lookups
MAXMIND_ACCOUNT_ID=
MAXMIND_LICENSE_KEY=

# API URL override for local testing with mock server
# Production uses https://geoip.maxmind.com (default)
# Local testing: http://mock-geoip:5556
MAXMIND_API_URL=

# GeoIP cache settings
GEOIP_CACHE_HOURS=24
GEOIP_CACHE_SIZE=1000

# =============================================================================
# POWERDNS BACKEND CONFIGURATION
# =============================================================================

# PowerDNS API credentials (config-driven, never hardcoded)
# Generate secure API key: openssl rand -hex 32
POWERDNS_API_KEY=7e822b0074b314527aad992f3deb6b851c83b6d6bbe18aaf3b4ae689b13149e3

# PowerDNS API URL (internal Docker network)
# Default: http://naf-dev-powerdns:8081 (from .env.services)
# Override for remote PowerDNS instances
POWERDNS_API_URL=

# PowerDNS DNS server address (public, port 53)
# Used for DNS delegation NS records
# Auto-detected from PUBLIC_FQDN (set by detect-fqdn.sh)
# Example: gstammtisch.dchive.de (A/AAAA records point to PowerDNS container host)
POWERDNS_NS_HOSTNAME=

# Default TTL for PowerDNS records (seconds)
# Benefit of self-hosting: can set as low as 1 second
POWERDNS_DEFAULT_TTL=60

# =============================================================================
# IMAP CONFIGURATION (Live Email Verification Tests)
# =============================================================================
# NOTE: Mailpit configuration is in tooling/mailpit/.env (container-specific)
# Tests read MAILPIT_* from environment variables (no defaults in code)
# =============================================================================
# Used for test_live_email_verification.py to verify email delivery
# Configure these for live mode testing only

# IMAP server hostname
IMAP_HOST=
# IMAP port (993 for TLS, 143 for STARTTLS)
IMAP_PORT=993
# IMAP username (usually email address)
IMAP_USER=
# IMAP password
IMAP_PASSWORD=
# Use TLS for IMAP connection
IMAP_USE_TLS=true
# Mailbox to check (usually INBOX)
IMAP_MAILBOX=INBOX
# Timeout in seconds for IMAP operations
IMAP_TIMEOUT=30

# =============================================================================
# LIVE DNS VERIFICATION CONFIGURATION
# =============================================================================
# Used for test_live_dns_verification.py to verify DNS changes
# Configure with a subdomain you control for testing

# Test subdomain prefix (will create records like <prefix>.example.com)
DNS_TEST_SUBDOMAIN_PREFIX=_naftest
# DNS propagation check timeout in seconds
DNS_PROPAGATION_TIMEOUT=300
# DNS servers to check for propagation
DNS_CHECK_SERVERS=8.8.8.8,1.1.1.1

# =============================================================================
# DDNS PROTOCOL SUPPORT
# =============================================================================
# Configuration for DynDNS2 and No-IP compatible DDNS endpoints

# Enable DDNS protocol endpoints (/api/ddns/dyndns2/update, /api/ddns/noip/update)
DDNS_PROTOCOLS_ENABLED=true

# Keywords that trigger auto IP detection (comma-separated, case-insensitive)
# When myip parameter matches any of these (or is empty), use client IP
# Example: myip=auto, myip=public, myip=detect, myip= (empty)
DDNS_AUTO_IP_KEYWORDS=auto,public,detect
