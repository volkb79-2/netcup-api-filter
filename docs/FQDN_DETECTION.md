# FQDN Detection and Dynamic Configuration

## Overview

This project uses **dynamic FQDN detection** to avoid hardcoding hostnames like `gstammtisch.dchive.de`. The public FQDN is auto-detected via reverse DNS lookup and used throughout scripts, tests, and deployment.

---

## Architecture

### Single Source of Truth: `.env.workspace`

All scripts source PUBLIC_FQDN from `.env.workspace`:

```bash
export PUBLIC_FQDN="gstammtisch.dchive.de"  # Auto-detected
export PUBLIC_IP="152.53.179.117"            # Auto-detected
export PUBLIC_TLS_CRT_PEM="/etc/letsencrypt/live/${PUBLIC_FQDN}/fullchain.pem"
export PUBLIC_TLS_KEY_PEM="/etc/letsencrypt/live/${PUBLIC_FQDN}/privkey.pem"
```

### Detection Script: `detect-fqdn.sh`

Centralized script for FQDN detection:

```bash
# Detect and print (for manual inspection)
./detect-fqdn.sh

# Update .env.workspace automatically
./detect-fqdn.sh --update-workspace

# Silent mode (exit code indicates success)
./detect-fqdn.sh --silent && echo "Success"
```

**Detection Process**:
1. Query external IP endpoints (ipify.org, icanhazip.com)
2. Perform reverse DNS lookup: `dig -x $PUBLIC_IP`
3. Extract FQDN from PTR record
4. Fallback to `localhost` if no reverse DNS

---

## Usage in Scripts

### Bash Scripts

```bash
#!/usr/bin/env bash
set -euo pipefail

# Source workspace environment (includes PUBLIC_FQDN)
source "${REPO_ROOT:-.}/.env.workspace"

# Use PUBLIC_FQDN in URLs
echo "Testing against: https://${PUBLIC_FQDN}/"

# Construct LOCAL_BASE_URL dynamically
source .env.defaults
LOCAL_BASE_URL=$(get_local_base_url)
echo "Local endpoint: ${LOCAL_BASE_URL}"
```

### Python Tests

```python
import os

# Read from environment (set by sourcing .env.workspace)
PUBLIC_FQDN = os.environ.get("PUBLIC_FQDN", "localhost")
LOCAL_USE_HTTPS = os.environ.get("LOCAL_USE_HTTPS", "true") == "true"

# Construct base URL
if LOCAL_USE_HTTPS:
    BASE_URL = f"https://{PUBLIC_FQDN}"
else:
    BASE_URL = f"http://localhost:{os.environ.get('LOCAL_FLASK_PORT', '5100')}"
```

### Environment Variable Override

```bash
# Override detection (e.g., for testing different domains)
export PUBLIC_FQDN="test.example.com"
./run-local-tests.sh

# Force specific IP/FQDN during detection
export FORCE_PUBLIC_IP="203.0.113.42"
export FORCE_FQDN="custom.domain.com"
./detect-fqdn.sh --update-workspace
```

---

## Configuration Files

### `.env.workspace` (Auto-generated)

Generated by devcontainer post-create script or `detect-fqdn.sh`:

```bash
export PUBLIC_FQDN="gstammtisch.dchive.de"
export PUBLIC_IP="152.53.179.117"
export PUBLIC_TLS_CRT_PEM="/etc/letsencrypt/live/gstammtisch.dchive.de/fullchain.pem"
export PUBLIC_TLS_KEY_PEM="/etc/letsencrypt/live/gstammtisch.dchive.de/privkey.pem"
```

### `.env.defaults` (Version-controlled defaults)

Defines helper function for dynamic URL construction:

```bash
LOCAL_USE_HTTPS=true
LOCAL_FLASK_PORT=5100

# Helper function (bash only)
get_local_base_url() {
    if [[ "$LOCAL_USE_HTTPS" == "true" ]]; then
        echo "https://${PUBLIC_FQDN:-localhost}"
    else
        echo "http://localhost:${LOCAL_FLASK_PORT}"
    fi
}
```

### `tooling/reverse-proxy/proxy.env`

TLS proxy configuration reads from `.env.workspace`:

```bash
# Uses PUBLIC_FQDN from environment
LOCAL_TLS_DOMAIN=${PUBLIC_FQDN:-gstammtisch.dchive.de}
```

---

## Documentation Conventions

### Use `$PUBLIC_FQDN` in Examples

**Before** (hardcoded ❌):
```bash
curl https://gstammtisch.dchive.de/admin/login
```

**After** (generic ✅):
```bash
curl https://$PUBLIC_FQDN/admin/login
```

### Use `$LOCAL_BASE_URL` for Local Tests

**Before** (hardcoded ❌):
```python
UI_BASE_URL = "http://localhost:5100"
```

**After** (dynamic ✅):
```python
# Source from environment
UI_BASE_URL = os.environ.get("LOCAL_BASE_URL") or compute_base_url()
```

---

## Migration Guide

### Replacing Hardcoded FQDNs

```bash
# Find all hardcoded references
rg "gstammtisch\.dchive\.de" --type-not md

# Replace with dynamic variable
sed -i 's|gstammtisch\.dchive\.de|${PUBLIC_FQDN}|g' script.sh

# For documentation, use placeholder
sed -i 's|gstammtisch\.dchive\.de|$PUBLIC_FQDN|g' docs/*.md
```

### Updating Scripts

1. **Add environment sourcing**:
   ```bash
   # At top of script
   source "${REPO_ROOT:-.}/.env.workspace"
   ```

2. **Replace hardcoded URLs**:
   ```bash
   # Before
   URL="https://gstammtisch.dchive.de/api"
   
   # After
   URL="https://${PUBLIC_FQDN}/api"
   ```

3. **Use get_local_base_url()**:
   ```bash
   source .env.defaults
   LOCAL_BASE_URL=$(get_local_base_url)
   curl "${LOCAL_BASE_URL}/health"
   ```

---

## Testing Different Domains

### Test with Custom FQDN

```bash
# Set custom domain
export PUBLIC_FQDN="naf.example.com"

# Regenerate proxy config
cd tooling/reverse-proxy
./render-nginx-conf.sh
./stage-proxy-inputs.sh

# Run tests
cd ../..
./run-local-tests.sh
```

### Test HTTP vs HTTPS

```bash
# Test with HTTP (localhost)
export LOCAL_USE_HTTPS=false
LOCAL_BASE_URL=$(get_local_base_url)
# Result: http://localhost:5100

# Test with HTTPS (public FQDN)
export LOCAL_USE_HTTPS=true
LOCAL_BASE_URL=$(get_local_base_url)
# Result: https://gstammtisch.dchive.de
```

---

## Troubleshooting

### PUBLIC_FQDN Not Set

**Symptom**: Scripts fail with "PUBLIC_FQDN: unbound variable"

**Solution**:
```bash
# Source workspace environment
source .env.workspace

# Or regenerate it
./detect-fqdn.sh --update-workspace
```

### Reverse DNS Not Configured

**Symptom**: `detect-fqdn.sh` returns "localhost"

**Solution**:
```bash
# Manually set FQDN
export PUBLIC_FQDN="your-domain.com"
./detect-fqdn.sh --update-workspace

# Or use FORCE_FQDN permanently
echo 'export FORCE_FQDN="your-domain.com"' >> ~/.bashrc
```

### Certificate Path Mismatch

**Symptom**: nginx fails with "certificate not found"

**Solution**:
```bash
# Verify cert path
ls -l /etc/letsencrypt/live/${PUBLIC_FQDN}/

# Check PUBLIC_TLS_CRT_PEM variable
echo $PUBLIC_TLS_CRT_PEM

# Regenerate if needed
./detect-fqdn.sh --update-workspace
source .env.workspace
```

---

## Related Files

| File | Purpose |
|------|---------|
| `.env.workspace` | Single source of truth for PUBLIC_FQDN |
| `detect-fqdn.sh` | FQDN detection script |
| `.env.defaults` | Default config + helper functions |
| `tooling/reverse-proxy/auto-detect-fqdn.sh` | Legacy detection (use `detect-fqdn.sh` instead) |
| `tooling/reverse-proxy/proxy.env` | TLS proxy config (reads PUBLIC_FQDN) |

---

## Best Practices

1. **Never hardcode FQDNs** - Always use `${PUBLIC_FQDN}` variable
2. **Source .env.workspace** - Before using PUBLIC_FQDN in scripts
3. **Use get_local_base_url()** - For constructing local URLs dynamically
4. **Document with placeholders** - Use `$PUBLIC_FQDN` in docs/examples
5. **Test both HTTP and HTTPS** - Toggle `LOCAL_USE_HTTPS` for coverage

---

## History

| Date | Change | Author |
|------|--------|--------|
| 2024-12-08 | Centralized FQDN detection, removed hardcoded references | AI Agent |
