# Local Development Workflow

This guide covers the standard workflow for building, deploying, and testing the application locally. The primary tool for this is the `./build-and-deploy-local.sh` script, which automates the entire process to ensure consistency and production parity.

## Key Principles

1.  **Configuration-Driven:** All aspects of the local deployment are controlled by environment variables. There are no hardcoded paths or credentials in the scripts.
2.  **State Persistence:** The state of the local deployment (like the auto-generated admin password) is persisted in `.env.local`. This allows tests to run sequentially without needing to reset the database each time.
3.  **Filesystem Consistency:** All scripts use the `$PHYSICAL_REPO_ROOT` environment variable to construct absolute paths. This ensures that paths work correctly both inside the devcontainer and within the Playwright test container, which has a mirrored filesystem layout.

## The `.env.local` File

-   **Purpose:** Stores the dynamic state of the *current* local deployment.
-   **Generated By:** The `./build-and-deploy-local.sh` script.
-   **Contents:**
    -   `DEPLOYED_ADMIN_PASSWORD`: The secure, randomly generated password for the `admin` user. This is created during the first authentication test run.
    -   `DEPLOYED_CLIENT_ID` & `DEPLOYED_CLIENT_SECRET_KEY`: Credentials for the primary pre-seeded demo client.
    -   `DEPLOYED_AT`, `DEPLOYED_COMMIT`: Metadata about the build.
-   **Git Status:** This file is in `.gitignore` and should **never** be committed to the repository.

## The `$PHYSICAL_REPO_ROOT` Variable

-   **Purpose:** Provides a stable, absolute path to the repository root on the host machine.
-   **Source:** Defined in `.env.workspace` during the devcontainer's post-create setup.
-   **Usage:** All scripts that need to reference file paths (e.g., in `docker-compose.yml` volume mounts or in test runners) **MUST** use this variable. This avoids issues with relative paths and differences between the container's and the host's filesystem.

**Example:**
```bash
# Correct: Using the absolute path variable
volumes:
  - ${PHYSICAL_REPO_ROOT:?PHYSICAL_REPO_ROOT must be set}/..:/workspaces:rw

# Incorrect: Using a relative path that can break
volumes:
  - ../..:/workspaces:rw
```

## Standard Workflow with `build-and-deploy-local.sh`

This is the canonical script for local development.

**Command:**
```bash
./build-and-deploy-local.sh
```

**What it does:**

1.  **Loads Config:** Reads defaults from `.env.defaults` and overrides from `.env.local`.
2.  **Builds Package:** Creates a fresh `deploy/` directory and `deploy.zip` package, just like for production.
3.  **Deploys Locally:** Extracts the build to `deploy-local/`.
4.  **Starts Playwright Container:** Ensures the test container is running with the correct configuration and filesystem mounts.
5.  **Starts Flask:** Launches the application backend using Gunicorn.
6.  **Runs Auth Test:** Executes the initial authentication test, which logs in with the default password, changes it to a secure random password, and persists it to `.env.local`.
7.  **Captures Screenshots:** Runs the screenshot capture script against the live local application, using the new password from `.env.local`.

This end-to-end process validates the entire stack and ensures that what you test locally is identical to what gets deployed.
