#!/usr/bin/env python3
"""Generate a route-vs-tests coverage report.

Goal
- Inventory all Flask routes from app.url_map.
- Extract URL paths referenced by UI tests.
- Produce a gap report highlighting routes not referenced by tests.

Notes
- This script does NOT execute HTTP requests.
- It is safe to run locally and in CI.
- It aims to be robust against simple f-strings by matching path literals.

Config (env-driven)
- COVERAGE_TEST_ROOT: folder to scan for tests (default: ui_tests/tests)
- COVERAGE_INCLUDE_PREFIXES: comma-separated path prefixes to treat as app routes
  (default: /admin,/account,/api,/,/health)
- COVERAGE_OUT_JSON: optional path to write JSON output
- COVERAGE_OUT_MD: optional path to write Markdown output

Usage
  python3 tooling/coverage/route_vs_tests_report.py \
    --out-json tmp/route_coverage.json \
    --out-md docs/TEST_COVERAGE_ROUTE_DIFF.md
"""

from __future__ import annotations

import argparse
import json
import os
import re
from collections import defaultdict
from dataclasses import asdict
from pathlib import Path
from typing import Any, Dict, Iterable, List, Set, Tuple


def _env(name: str, default: str) -> str:
    return os.environ.get(name, default)


def _normalize_rule(rule: str) -> str:
    return re.sub(r"<[^>]+>", "<param>", rule)


def _load_routes() -> List[Dict[str, Any]]:
    os.environ.setdefault("FLASK_ENV", "testing")
    os.environ.setdefault("SECRET_KEY", "route-discovery-key")

    # Import via route_discovery to keep one canonical codepath.
    from ui_tests.route_discovery import discover_routes_from_app

    registry = discover_routes_from_app()
    routes: List[Dict[str, Any]] = []
    for r in registry.routes:
        routes.append(
            {
                "rule": r.rule,
                "endpoint": r.endpoint,
                "methods": sorted(r.methods),
                "blueprint": r.blueprint,
                "category": r.category,
                "auth_required": r.auth_required,
                "has_params": r.has_params,
                "is_get": r.is_get,
            }
        )
    return routes


def _scan_test_paths(test_root: Path, include_prefixes: Tuple[str, ...]) -> Set[str]:
    # Extract string literals that look like URL paths.
    # Keep it conservative to avoid pulling in random file paths.
    literal_path_re = re.compile(r"(?P<q>['\"])(/(?:(?!\1).){1,200})\1")

    tested: Set[str] = set()
    for py in sorted(test_root.rglob("*.py")):
        text = py.read_text(encoding="utf-8")
        for match in literal_path_re.finditer(text):
            path = match.group(2)
            if not path.startswith("/") or path.startswith("//"):
                continue
            if any(path == p or path.startswith(p.rstrip("/") + "/") for p in include_prefixes):
                tested.add(path)
    return tested


def _coverage_diff(routes: List[Dict[str, Any]], tested_paths: Set[str]) -> Dict[str, Any]:
    normalized_tested = {_normalize_rule(p) for p in tested_paths}

    covered_exact: List[str] = []
    covered_prefix: List[str] = []
    missing: List[str] = []

    for r in routes:
        rule = r["rule"]
        norm = _normalize_rule(rule)

        if rule in tested_paths or norm in normalized_tested:
            covered_exact.append(rule)
            continue

        if r["has_params"]:
            static_prefix = rule.split("<", 1)[0]
            if any(tp.startswith(static_prefix) for tp in tested_paths):
                covered_prefix.append(rule)
            else:
                missing.append(rule)
        else:
            missing.append(rule)

    missing_by_area: Dict[str, List[str]] = defaultdict(list)
    for rule in sorted(set(missing)):
        if rule.startswith("/admin"):
            missing_by_area["admin"].append(rule)
        elif rule.startswith("/account"):
            missing_by_area["account"].append(rule)
        elif rule.startswith("/api"):
            missing_by_area["api"].append(rule)
        else:
            missing_by_area["misc"].append(rule)

    return {
        "summary": {
            "total_routes": len(routes),
            "tested_literal_paths_found": len(tested_paths),
            "covered_exact_count": len(covered_exact),
            "covered_prefix_count": len(covered_prefix),
            "missing_count": len(missing),
        },
        "covered_exact": sorted(set(covered_exact)),
        "covered_prefix": sorted(set(covered_prefix)),
        "missing_by_area": missing_by_area,
    }


def _render_md(diff: Dict[str, Any]) -> str:
    s = diff["summary"]
    lines: List[str] = []
    lines.append("# Route vs UI Test Coverage Report")
    lines.append("")
    lines.append("This report is generated by `tooling/coverage/route_vs_tests_report.py`.")
    lines.append("")
    lines.append("## Summary")
    lines.append("")
    lines.append(f"- Total routes discovered: **{s['total_routes']}**")
    lines.append(f"- Test path literals found: **{s['tested_literal_paths_found']}**")
    lines.append(f"- Covered (exact): **{s['covered_exact_count']}**")
    lines.append(f"- Covered (prefix for param routes): **{s['covered_prefix_count']}**")
    lines.append(f"- Missing (not referenced): **{s['missing_count']}**")
    lines.append("")

    lines.append("## Missing Routes (Grouped)")
    lines.append("")
    for area in ("admin", "account", "api", "misc"):
        items = diff["missing_by_area"].get(area) or []
        lines.append(f"### {area}")
        lines.append("")
        if not items:
            lines.append("- (none)")
        else:
            for rule in items:
                lines.append(f"- `{rule}`")
        lines.append("")

    lines.append("## Notes")
    lines.append("")
    lines.append("- This is a *reference scan* (string literals in tests), not full behavioral coverage.")
    lines.append("- Param routes (e.g. `/admin/accounts/<int:id>`) are treated as covered if any test references the static prefix.")
    lines.append("- If a route is missing but is invoked via form POST without a literal path, add an explicit test reference or extend the scanner.")

    return "\n".join(lines)


def main() -> int:
    parser = argparse.ArgumentParser()
    parser.add_argument("--out-json", default=_env("COVERAGE_OUT_JSON", ""))
    parser.add_argument("--out-md", default=_env("COVERAGE_OUT_MD", ""))

    args = parser.parse_args()

    test_root = Path(_env("COVERAGE_TEST_ROOT", "ui_tests/tests")).resolve()
    include_prefixes = tuple(
        p.strip() for p in _env("COVERAGE_INCLUDE_PREFIXES", "/admin,/account,/api,/,/health").split(",") if p.strip()
    )

    routes = _load_routes()
    tested_paths = _scan_test_paths(test_root, include_prefixes)
    diff = _coverage_diff(routes, tested_paths)

    payload = {
        "summary": diff["summary"],
        "missing_by_area": diff["missing_by_area"],
        "covered_exact": diff["covered_exact"],
        "covered_prefix": diff["covered_prefix"],
    }

    if args.out_json:
        out_json = Path(args.out_json)
        out_json.parent.mkdir(parents=True, exist_ok=True)
        out_json.write_text(json.dumps(payload, indent=2, sort_keys=True) + "\n", encoding="utf-8")

    if args.out_md:
        out_md = Path(args.out_md)
        out_md.parent.mkdir(parents=True, exist_ok=True)
        out_md.write_text(_render_md(diff) + "\n", encoding="utf-8")

    # Always print a compact summary for CLI use.
    print(json.dumps(payload["summary"], indent=2))
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
