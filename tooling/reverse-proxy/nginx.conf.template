# HTTPS server - TLS termination with Let's Encrypt certificates
# Template variables (substituted by render-nginx-conf.sh using envsubst):
#   ${LOCAL_TLS_DOMAIN}  - Public FQDN (e.g., gstammtisch.dchive.de)
#   ${LOCAL_APP_HOST}    - Backend hostname (e.g., netcup-api-filter-devcontainer)
#   ${LOCAL_APP_PORT}    - Backend port (e.g., 5100)
#   ${HOSTNAME_MAILPIT}  - Mailpit service hostname (from .env.services)
#   ${HOSTNAME_POWERDNS} - PowerDNS service hostname (from .env.services)

# Docker's embedded DNS resolver (allows runtime hostname resolution)
# This prevents nginx from failing at startup if upstreams are unavailable
resolver 127.0.0.11 valid=10s ipv6=off;

server {
    listen 443 ssl;
    # Server name matches the public FQDN (from proxy.env)
    server_name ${LOCAL_TLS_DOMAIN} _;

    # Certificate paths constructed from LOCAL_TLS_DOMAIN
    # Let's Encrypt structure: /etc/letsencrypt/live/<domain>/fullchain.pem
    ssl_certificate     /etc/letsencrypt/live/${LOCAL_TLS_DOMAIN}/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/${LOCAL_TLS_DOMAIN}/privkey.pem;
    ssl_protocols       TLSv1.2 TLSv1.3;
    ssl_prefer_server_ciphers on;
    
    # CRITICAL: disable_symlinks off allows nginx to follow Let's Encrypt symlinks
    # Let's Encrypt structure: live/<domain>/*.pem -> ../../archive/<domain>/*.pem
    disable_symlinks off;

    add_header Strict-Transport-Security "max-age=31536000; includeSubDomains" always;
    add_header X-Content-Type-Options nosniff;
    add_header X-Frame-Options SAMEORIGIN;
    add_header Referrer-Policy "strict-origin-when-cross-origin";

    # Mailpit web UI and API
    # Mailpit handles webroot internally via MP_WEBROOT environment variable
    location /mailpit/ {
        # Use variable to force runtime DNS resolution (nginx won't fail at startup if service unavailable)
        set $mailpit_upstream ${HOSTNAME_MAILPIT}:8025;
        # Proxy to Mailpit WITHOUT stripping prefix (Mailpit expects /mailpit/)
        proxy_pass http://$mailpit_upstream;
        proxy_http_version 1.1;
        
        # WebSocket support (for real-time UI updates)
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "upgrade";
        
        # Standard proxy headers
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        
        # Pass through basic auth credentials
        proxy_set_header Authorization $http_authorization;
        proxy_pass_header Authorization;
        
        # Disable buffering for SSE/WebSocket
        proxy_buffering off;
    }

    # PowerDNS API
    # Secured by PowerDNS API key (X-API-Key header)
    location /backend-powerdns/ {
        # Use variable to force runtime DNS resolution (nginx won't fail at startup if service unavailable)
        set $powerdns_upstream ${HOSTNAME_POWERDNS}:8081;
        # Strip /backend-powerdns prefix, proxy to PowerDNS API root
        proxy_pass http://$powerdns_upstream/;
        proxy_http_version 1.1;
        
        # Standard proxy headers
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        
        # Pass through API key authentication
        proxy_set_header X-API-Key $http_x_api_key;
        proxy_pass_header X-API-Key;
        
        # Disable buffering for API responses
        proxy_buffering off;
    }

    location / {
        # Use variable to force runtime DNS resolution (nginx won't fail at startup if service unavailable)
        set $backend_upstream ${LOCAL_APP_HOST}:${LOCAL_APP_PORT};
        # Forward all requests to Flask backend (HTTP, not HTTPS)
        # nginx terminates TLS, backend receives plain HTTP
        proxy_pass http://$backend_upstream;
        proxy_http_version 1.1;
        
        # Preserve original Host header
        proxy_set_header Host $host;
        
        # Forward client IP (for rate limiting, logging)
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        
        # CRITICAL: Tell Flask the request came via HTTPS
        # Flask uses this to set Secure flag on session cookies
        proxy_set_header X-Forwarded-Proto https;
        
        # Preserve original hostname and port
        proxy_set_header X-Forwarded-Host $host;
        proxy_set_header X-Forwarded-Port 443;
        
        # Disable automatic redirect rewriting
        proxy_redirect off;
    }
}

# HTTP server - redirect all traffic to HTTPS
server {
    listen 80;
    server_name ${LOCAL_TLS_DOMAIN} _;
    # 301 Moved Permanently - browsers will cache this redirect
    return 301 https://$host$request_uri;
}
